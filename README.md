# Hack day 1 reflections
Some questions for reflective learning, engineering team.

Hack Day 1 simulated your first real-world project.

- You pull the codebase that exists
- A new feature is decided upon
- You figure out what is missing from the codebase to add that feature
- The team adds the feature
- You release the feature to users

## Unknown unknowns
It is never the things you know how to do that kill a project - it is the things you don't see coming.

> Humans have limited foresight. 
>
> Agility *embraces* change rather than hiding from it

- What things took the most time?
- Did you expect them to?
- Would a fixed plan at the start of the day work?
- What could a plan *not* have foreseen?

## Finding information
We can never know it all in advance. On every feature, there will likely be one new thing to learn.

> First days at new projects are *hard*. Everything is new to you

- How easy was it to read AWS/Azure documentation?
- How easy was it to use search engines to find what you need?
- What assumptions did you make at the start of the day?
- Did any assumption prove to be incorrect?
- How much time did false assumptions waste?
- What unexpected obstacles happened?
- How did you work to resolve them?
- What else would you do in future?

## Teamwork
We do not - *cannot* - work alone anymore. We work as one team.

- Did you divide work by technology or feature?
- How did your choice contribute to delivery of product increments?
- How frequently did you commit your work to the shared whole?
- How frequently did you pull down others work from the shared whole?
- Did you feel a right balance between designer wishes and engineering constraints?
- How would we achieve better want/constraint balance?

## Early and frequent delivery of value
Nobody cares about empty promises, "almost worked" nor slidedecks. Only working software, delivered, counts.

> Working software over comprehensive documentation

- Did you have early and frequent delivery of an increment?
- How many increments were delivered successfully by your team?
- Did you consider interim increments where a missing piece was either faked/ hard coded / simplistic implementation?
- Did anyone get a faked user journey delivered and then flesh out the real implementation in later increments?
- Did you use fixed increment lengths, or use a kanban approach?
- Did fixed increment lengths help or hinder? What would you choose in hindsight?
- What was the first time in the day you had a minimal full system working?
- What could you have done to reduce the time to first increment?

## System design considerations
Some code is easier to work with and change than other code - even when they do the same thing.

- Were you able to identify the missing technology pieces?
- What technical choices hindered agility?
- Which tech choices improved agility?
- How were you able to leverage your existing programming knowledge?

## Agile Manifesto application
Day 4 was all about learning the [principles](https://agilemanifesto.org/principles.html) of agility from the [Agile Manifesto](https://agilemanifesto.org/)

- In what ways did you value individual interactions over processes and tools?
- Did they help?
- How?
- In what ways did you value working software over documentation (slides, wireframes, source code only running locally)?
- Could you have done more? 
- What would you do differently?
- Doing this again, what could have been your first increment that would have shown progress towards the goal?



